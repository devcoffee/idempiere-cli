package org.idempiere.cli.model;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Represents code generated by AI, structured as a set of files
 * plus optional metadata changes (MANIFEST.MF additions, etc.).
 */
@JsonIgnoreProperties(ignoreUnknown = true)
public class GeneratedCode {

    private static final Pattern IMPORT_HEADER_PATTERN = Pattern.compile(
            "(Import-Package:\\s*)([^\\n]+(?:\\n\\s+[^\\n]+)*)",
            Pattern.MULTILINE
    );

    @JsonProperty("files")
    private List<GeneratedFile> files;

    @JsonProperty("manifest_additions")
    private List<String> manifestAdditions;

    @JsonProperty("build_properties_additions")
    private List<String> buildPropertiesAdditions;

    public GeneratedCode() {}

    public List<GeneratedFile> getFiles() {
        return files != null ? files : List.of();
    }

    public void setFiles(List<GeneratedFile> files) {
        this.files = files;
    }

    public List<String> getManifestAdditions() {
        return manifestAdditions != null ? manifestAdditions : List.of();
    }

    public void setManifestAdditions(List<String> manifestAdditions) {
        this.manifestAdditions = manifestAdditions;
    }

    public List<String> getBuildPropertiesAdditions() {
        return buildPropertiesAdditions != null ? buildPropertiesAdditions : List.of();
    }

    public void setBuildPropertiesAdditions(List<String> buildPropertiesAdditions) {
        this.buildPropertiesAdditions = buildPropertiesAdditions;
    }

    /**
     * Writes all generated files to the plugin directory.
     * Does NOT overwrite existing files.
     *
     * @param pluginDir the plugin root directory
     * @throws IOException if writing fails
     */
    public void writeTo(Path pluginDir) throws IOException {
        for (GeneratedFile file : getFiles()) {
            Path target = pluginDir.resolve(file.getPath());

            // Security: reject path traversal
            if (!target.normalize().startsWith(pluginDir.normalize())) {
                System.err.println("  Skipped (path traversal): " + file.getPath());
                continue;
            }

            if (Files.exists(target)) {
                System.err.println("  Skipped (already exists): " + target);
                continue;
            }

            Files.createDirectories(target.getParent());
            Files.writeString(target, file.getContent());
            System.out.println("  Created: " + target);
        }

        applyManifestAdditions(pluginDir);
        applyBuildPropertiesAdditions(pluginDir);
    }

    private void applyManifestAdditions(Path pluginDir) throws IOException {
        List<String> additions = normalizeManifestAdditions(getManifestAdditions());
        if (additions.isEmpty()) {
            return;
        }

        Path manifestPath = pluginDir.resolve("META-INF/MANIFEST.MF");
        if (!Files.exists(manifestPath)) {
            System.err.println("  Warning: MANIFEST.MF not found for AI additions: " + manifestPath);
            return;
        }

        String content = Files.readString(manifestPath);
        Set<String> existingPackages = parseExistingImportPackages(content);

        List<String> toAdd = new ArrayList<>();
        for (String addition : additions) {
            String packageName = packageName(addition);
            if (!existingPackages.contains(packageName)) {
                toAdd.add(addition);
                existingPackages.add(packageName);
            }
        }

        if (toAdd.isEmpty()) {
            return;
        }

        String updatedContent = addImportsToManifest(content, toAdd);
        Files.writeString(manifestPath, updatedContent);
        System.out.println("  Updated MANIFEST.MF with AI imports: "
                + String.join(", ", toAdd.stream().map(this::packageName).toList()));
    }

    private void applyBuildPropertiesAdditions(Path pluginDir) throws IOException {
        List<String> additions = normalizeBuildPropertiesAdditions(getBuildPropertiesAdditions());
        if (additions.isEmpty()) {
            return;
        }

        Path buildPropertiesPath = pluginDir.resolve("build.properties");
        if (!Files.exists(buildPropertiesPath)) {
            System.err.println("  Warning: build.properties not found for AI additions: " + buildPropertiesPath);
            return;
        }

        String content = Files.readString(buildPropertiesPath);
        Set<String> existingLines = new LinkedHashSet<>();
        for (String line : content.split("\\R")) {
            String trimmed = line.trim();
            if (!trimmed.isEmpty()) {
                existingLines.add(trimmed);
            }
        }

        List<String> toAdd = new ArrayList<>();
        for (String addition : additions) {
            String trimmed = addition.trim();
            if (trimmed.isEmpty() || existingLines.contains(trimmed)) {
                continue;
            }
            toAdd.add(addition);
            existingLines.add(trimmed);
        }

        if (toAdd.isEmpty()) {
            return;
        }

        StringBuilder updated = new StringBuilder(content);
        if (!content.endsWith("\n")) {
            updated.append("\n");
        }
        for (String line : toAdd) {
            updated.append(line).append("\n");
        }
        Files.writeString(buildPropertiesPath, updated.toString());
        System.out.println("  Updated build.properties with AI additions: " + toAdd.size() + " line(s)");
    }

    private List<String> normalizeManifestAdditions(List<String> additions) {
        LinkedHashMap<String, String> byPackage = new LinkedHashMap<>();

        for (String raw : additions) {
            if (raw == null || raw.isBlank()) {
                continue;
            }

            String normalizedRaw = raw.replace("Import-Package:", "")
                    .replace("\r", "")
                    .replace("\n", ",");
            List<String> tokens = splitCsvPreservingQuotes(normalizedRaw);
            for (String token : tokens) {
                String candidate = token.trim();
                if (candidate.isEmpty()) {
                    continue;
                }
                String pkg = packageName(candidate);
                if (!pkg.isEmpty()) {
                    byPackage.putIfAbsent(pkg, candidate);
                }
            }
        }

        return new ArrayList<>(byPackage.values());
    }

    private List<String> splitCsvPreservingQuotes(String input) {
        List<String> parts = new ArrayList<>();
        if (input == null || input.isBlank()) {
            return parts;
        }

        StringBuilder current = new StringBuilder();
        boolean inQuotes = false;

        for (int i = 0; i < input.length(); i++) {
            char ch = input.charAt(i);
            if (ch == '"') {
                inQuotes = !inQuotes;
                current.append(ch);
                continue;
            }
            if (ch == ',' && !inQuotes) {
                parts.add(current.toString());
                current.setLength(0);
                continue;
            }
            current.append(ch);
        }
        parts.add(current.toString());
        return parts;
    }

    private List<String> normalizeBuildPropertiesAdditions(List<String> additions) {
        List<String> normalized = new ArrayList<>();

        for (String raw : additions) {
            if (raw == null || raw.isBlank()) {
                continue;
            }
            String value = raw.replace("\r", "");
            if (value.startsWith("build.properties:")) {
                value = value.substring("build.properties:".length()).trim();
            }
            for (String line : value.split("\n")) {
                String trimmed = line.trim();
                if (!trimmed.isEmpty()) {
                    normalized.add(trimmed);
                }
            }
        }

        return normalized;
    }

    private Set<String> parseExistingImportPackages(String manifestContent) {
        Set<String> imports = new LinkedHashSet<>();
        Matcher matcher = IMPORT_HEADER_PATTERN.matcher(manifestContent);
        if (!matcher.find()) {
            return imports;
        }

        String importList = matcher.group(2).replaceAll("\\s+", " ").trim();
        for (String item : importList.split(",\\s*")) {
            String pkg = packageName(item);
            if (!pkg.isEmpty()) {
                imports.add(pkg);
            }
        }
        return imports;
    }

    private String addImportsToManifest(String content, List<String> importsToAdd) {
        Matcher matcher = IMPORT_HEADER_PATTERN.matcher(content);
        if (matcher.find()) {
            String existingValue = matcher.group(2).trim();
            if (existingValue.endsWith(",")) {
                existingValue = existingValue.substring(0, existingValue.length() - 1);
            }
            StringBuilder newValue = new StringBuilder(existingValue);
            for (String imp : importsToAdd) {
                newValue.append(",\n ").append(imp);
            }
            return matcher.replaceFirst("Import-Package: " + Matcher.quoteReplacement(newValue.toString()));
        }

        StringBuilder importHeader = new StringBuilder("Import-Package: ");
        boolean first = true;
        for (String imp : importsToAdd) {
            if (!first) {
                importHeader.append(",\n ");
            }
            importHeader.append(imp);
            first = false;
        }
        importHeader.append("\n");

        if (content.contains("Service-Component:")) {
            return content.replace("Service-Component:", importHeader + "Service-Component:");
        }
        if (content.contains("Bundle-ActivationPolicy:")) {
            return content.replace("Bundle-ActivationPolicy:", importHeader + "Bundle-ActivationPolicy:");
        }
        if (!content.endsWith("\n")) {
            content += "\n";
        }
        return content + importHeader;
    }

    private String packageName(String entry) {
        if (entry == null) {
            return "";
        }
        String value = entry.split(";")[0].trim();
        return value;
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class GeneratedFile {

        @JsonProperty("path")
        private String path;

        @JsonProperty("content")
        private String content;

        public GeneratedFile() {}

        public GeneratedFile(String path, String content) {
            this.path = path;
            this.content = content;
        }

        public String getPath() {
            return path;
        }

        public void setPath(String path) {
            this.path = path;
        }

        public String getContent() {
            return content;
        }

        public void setContent(String content) {
            this.content = content;
        }
    }
}
